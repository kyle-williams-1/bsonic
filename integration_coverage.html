
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bsonic: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kyle-williams-1/bsonic/bsonic.go (92.0%)</option>
				
				<option value="file1">github.com/kyle-williams-1/bsonic/config/config.go (100.0%)</option>
				
				<option value="file2">github.com/kyle-williams-1/bsonic/formatter/mongo/formatter.go (91.0%)</option>
				
				<option value="file3">github.com/kyle-williams-1/bsonic/language/lucene/parser.go (100.0%)</option>
				
				<option value="file4">github.com/kyle-williams-1/bsonic/registry/registry.go (75.0%)</option>
				
				<option value="file5">github.com/kyle-williams-1/bsonic/tests/shared/helpers/bson_helpers.go (78.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package bsonic provides a Lucene-style syntax parser for MongoDB BSON filters.
package bsonic

import (
        "strings"

        "github.com/kyle-williams-1/bsonic/config"
        "github.com/kyle-williams-1/bsonic/formatter"
        "github.com/kyle-williams-1/bsonic/language"
        "github.com/kyle-williams-1/bsonic/registry"
        "go.mongodb.org/mongo-driver/bson"

        // Import packages to trigger their init functions
        _ "github.com/kyle-williams-1/bsonic/formatter/mongo"
        _ "github.com/kyle-williams-1/bsonic/language/lucene"
)

// Parser represents a query parser for the selected language and MongoDB formatter.
type Parser struct {
        // Config holds the language and formatter configuration
        Config *config.Config
        // Language parser instance
        languageParser language.Parser
        // Formatter instance (generic)
        formatter formatter.Formatter[bson.M]
}

// NewParser creates a parser based on the language type using the registry.
func NewParser(langType config.LanguageType) (language.Parser, error) <span class="cov5" title="14">{
        return registry.DefaultRegistry.Languages.GetLanguage(langType)
}</span>

// NewFormatter creates a formatter based on the formatter type using the registry.
func NewFormatter(formatterType config.FormatterType) (formatter.Formatter[bson.M], error) <span class="cov5" title="15">{
        return registry.DefaultRegistry.Formatters.GetFormatter(formatterType)
}</span>

// NewMongoFormatter creates a MongoDB BSON formatter with proper typing.
func NewMongoFormatter() formatter.Formatter[bson.M] <span class="cov1" title="1">{
        formatter, _ := NewFormatter(config.FormatterMongo)
        return formatter
}</span>

// New creates a new parser instance with default configuration.
func New() *Parser <span class="cov4" title="11">{
        cfg := config.Default()
        languageParser, _ := NewParser(cfg.Language)
        formatter, _ := NewFormatter(cfg.Formatter)

        return &amp;Parser{
                Config:         cfg,
                languageParser: languageParser,
                formatter:      formatter,
        }
}</span>

// NewWithConfig creates a new parser with custom configuration.
func NewWithConfig(cfg *config.Config) (*Parser, error) <span class="cov2" title="3">{
        // Validate the configuration using the registry
        if err := registry.DefaultRegistry.ValidateConfig(cfg); err != nil </span><span class="cov2" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">languageParser, err := NewParser(cfg.Language)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">formatter, err := NewFormatter(cfg.Formatter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;Parser{
                Config:         cfg,
                languageParser: languageParser,
                formatter:      formatter,
        }, nil</span>
}

// Parse converts a query string into a BSON document.
// This is the recommended way to parse queries for most use cases.
func Parse(query string) (bson.M, error) <span class="cov1" title="1">{
        parser := New()
        return parser.Parse(query)
}</span>

// Parse converts a query string into a BSON document.
func (p *Parser) Parse(query string) (bson.M, error) <span class="cov10" title="228">{
        if strings.TrimSpace(query) == "" </span><span class="cov4" title="7">{
                return bson.M{}, nil
        }</span>

        // Parse the query and let the formatter handle it
        <span class="cov9" title="221">ast, err := p.languageParser.Parse(query)
        if err != nil </span><span class="cov5" title="16">{
                return nil, err
        }</span>

        <span class="cov9" title="205">return p.formatter.Format(ast)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package config provides configuration for language and formatter selection.
package config

// LanguageType represents the type of query language to use.
type LanguageType string

const (
        // LanguageLucene represents Lucene-style query syntax
        LanguageLucene LanguageType = "lucene"
)

// FormatterType represents the type of output formatter to use.
type FormatterType string

const (
        // FormatterMongo represents MongoDB BSON output format
        FormatterMongo FormatterType = "mongo"
)

// Config represents the configuration for a parser.
type Config struct {
        Language  LanguageType
        Formatter FormatterType
}

// Default returns the default configuration with Lucene language and MongoDB formatter.
func Default() *Config <span class="cov10" title="12">{
        return &amp;Config{
                Language:  LanguageLucene,
                Formatter: FormatterMongo,
        }
}</span>

// WithLanguage sets the language type and returns the config.
func (c *Config) WithLanguage(lang LanguageType) *Config <span class="cov1" title="1">{
        c.Language = lang
        return c
}</span>

// WithFormatter sets the formatter type and returns the config.
func (c *Config) WithFormatter(formatter FormatterType) *Config <span class="cov1" title="1">{
        c.Formatter = formatter
        return c
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package mongo provides MongoDB BSON formatting functionality for query results.
package mongo

import (
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/kyle-williams-1/bsonic/config"
        "github.com/kyle-williams-1/bsonic/formatter"
        "github.com/kyle-williams-1/bsonic/language/lucene"
        "github.com/kyle-williams-1/bsonic/registry"
        "go.mongodb.org/mongo-driver/bson"
)

// MongoFormatter represents a MongoDB BSON formatter for query results.
type MongoFormatter struct{}

// New creates a new MongoDB BSON formatter instance.
func New() *MongoFormatter <span class="cov4" title="15">{
        return &amp;MongoFormatter{}
}</span>

// Format converts a parsed query AST into a BSON document.
func (f *MongoFormatter) Format(ast interface{}) (bson.M, error) <span class="cov7" title="205">{
        // Type assert to the ParticipleQuery AST type from the Lucene parser
        participleQuery, ok := ast.(*lucene.ParticipleQuery)
        if !ok </span><span class="cov0" title="0">{
                return bson.M{}, fmt.Errorf("expected *lucene.ParticipleQuery AST, got %T", ast)
        }</span>

        <span class="cov7" title="205">if participleQuery.Expression == nil </span><span class="cov0" title="0">{
                return bson.M{}, nil
        }</span>
        <span class="cov7" title="205">return f.expressionToBSON(participleQuery.Expression), nil</span>
}

// parseValue parses a value string, handling wildcards, dates, and special syntax
func (f *MongoFormatter) parseValue(valueStr string) (interface{}, error) <span class="cov8" title="472">{
        // Create a chain of value parsers
        parsers := []func(string) (interface{}, error, bool){
                f.tryParseRange,
                f.tryParseComparison,
                f.tryParseRegex,
                f.tryParseWildcard,
                f.tryParseDate,
                f.tryParseNumber,
                f.tryParseBoolean,
        }

        for _, parser := range parsers </span><span class="cov10" title="2650">{
                if result, err, handled := parser(valueStr); handled </span><span class="cov7" title="239">{
                        return result, err
                }</span>
        }

        // Default: return as string
        <span class="cov7" title="233">return valueStr, nil</span>
}

// tryParseRange attempts to parse a range value
func (f *MongoFormatter) tryParseRange(valueStr string) (interface{}, error, bool) <span class="cov8" title="472">{
        if strings.HasPrefix(valueStr, "[") &amp;&amp; strings.HasSuffix(valueStr, "]") &amp;&amp; strings.Contains(strings.ToUpper(valueStr), " TO ") </span><span class="cov5" title="41">{
                result, err := f.parseRange(valueStr)
                return result, err, true
        }</span>
        <span class="cov7" title="431">return nil, nil, false</span>
}

// tryParseComparison attempts to parse a comparison value
func (f *MongoFormatter) tryParseComparison(valueStr string) (interface{}, error, bool) <span class="cov7" title="431">{
        if strings.HasPrefix(valueStr, "&gt;=") || strings.HasPrefix(valueStr, "&lt;=") || strings.HasPrefix(valueStr, "&gt;") || strings.HasPrefix(valueStr, "&lt;") </span><span class="cov5" title="44">{
                result, err := f.parseComparison(valueStr)
                return result, err, true
        }</span>
        <span class="cov7" title="387">return nil, nil, false</span>
}

// tryParseWildcard attempts to parse a wildcard value
func (f *MongoFormatter) tryParseWildcard(valueStr string) (interface{}, error, bool) <span class="cov7" title="379">{
        if strings.Contains(valueStr, "*") </span><span class="cov4" title="30">{
                result, err := f.parseWildcard(valueStr)
                return result, err, true
        }</span>
        <span class="cov7" title="349">return nil, nil, false</span>
}

// tryParseRegex attempts to parse a regex value
func (f *MongoFormatter) tryParseRegex(valueStr string) (interface{}, error, bool) <span class="cov7" title="387">{
        if strings.HasPrefix(valueStr, "/") &amp;&amp; strings.HasSuffix(valueStr, "/") &amp;&amp; len(valueStr) &gt; 2 </span><span class="cov3" title="8">{
                result, err := f.parseRegex(valueStr)
                return result, err, true
        }</span>
        <span class="cov7" title="379">return nil, nil, false</span>
}

// tryParseDate attempts to parse a date value
func (f *MongoFormatter) tryParseDate(valueStr string) (interface{}, error, bool) <span class="cov7" title="349">{
        if date, err := f.parseDate(valueStr); err == nil </span><span class="cov3" title="6">{
                return date, nil, true
        }</span>
        <span class="cov7" title="343">return nil, nil, false</span>
}

// tryParseNumber attempts to parse a number value
func (f *MongoFormatter) tryParseNumber(valueStr string) (interface{}, error, bool) <span class="cov7" title="343">{
        if num, err := strconv.ParseFloat(valueStr, 64); err == nil </span><span class="cov5" title="54">{
                return num, nil, true
        }</span>
        <span class="cov7" title="289">return nil, nil, false</span>
}

// tryParseBoolean attempts to parse a boolean value
func (f *MongoFormatter) tryParseBoolean(valueStr string) (interface{}, error, bool) <span class="cov7" title="289">{
        if valueStr == "true" || valueStr == "false" </span><span class="cov5" title="56">{
                return valueStr == "true", nil, true
        }</span>
        <span class="cov7" title="233">return nil, nil, false</span>
}

// parseRange parses range queries like [start TO end] for both dates and numbers
func (f *MongoFormatter) parseRange(valueStr string) (interface{}, error) <span class="cov5" title="41">{
        rangeStr := strings.Trim(valueStr, "[]")
        parts := strings.Split(strings.ToUpper(rangeStr), " TO ")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid range format: expected [start TO end]")
        }</span>

        <span class="cov5" title="41">startStr := strings.TrimSpace(parts[0])
        endStr := strings.TrimSpace(parts[1])

        if f.isDateLike(startStr) || f.isDateLike(endStr) </span><span class="cov4" title="15">{
                return f.parseDateRange(startStr, endStr)
        }</span>

        <span class="cov4" title="26">return f.parseNumberRange(startStr, endStr)</span>
}

// parseComparison parses comparison operators like &gt;value, &lt;value, &gt;=value, &lt;=value
func (f *MongoFormatter) parseComparison(valueStr string) (interface{}, error) <span class="cov5" title="44">{
        operator, value, err := f.extractOperatorAndValue(valueStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="44">value = strings.TrimSpace(value)

        if f.isDateLike(value) </span><span class="cov4" title="22">{
                return f.parseDateComparison(operator, value)
        }</span>

        <span class="cov4" title="22">return f.parseNumberComparison(operator, value)</span>
}

// extractOperatorAndValue extracts the operator and value from a comparison string
func (f *MongoFormatter) extractOperatorAndValue(valueStr string) (string, string, error) <span class="cov5" title="44">{
        comparisonOperators := []struct {
                prefix   string
                operator string
        }{
                {"&gt;=", "$gte"},
                {"&lt;=", "$lte"},
                {"&gt;", "$gt"},
                {"&lt;", "$lt"},
        }

        for _, op := range comparisonOperators </span><span class="cov6" title="131">{
                if strings.HasPrefix(valueStr, op.prefix) </span><span class="cov5" title="44">{
                        return op.operator, valueStr[len(op.prefix):], nil
                }</span>
        }

        <span class="cov0" title="0">return "", "", errors.New("invalid comparison operator")</span>
}

// parseDateComparison parses a date comparison
func (f *MongoFormatter) parseDateComparison(operator, value string) (interface{}, error) <span class="cov4" title="22">{
        date, err := f.parseDate(value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="22">return bson.M{operator: date}, nil</span>
}

// parseNumberComparison parses a number comparison
func (f *MongoFormatter) parseNumberComparison(operator, value string) (interface{}, error) <span class="cov4" title="22">{
        num, err := strconv.ParseFloat(value, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid number: %v", err)
        }</span>
        <span class="cov4" title="22">return bson.M{operator: num}, nil</span>
}

// isDateLike checks if a string looks like a date
func (f *MongoFormatter) isDateLike(s string) bool <span class="cov6" title="114">{
        if s == "*" </span><span class="cov4" title="14">{
                return false
        }</span>
        <span class="cov6" title="100">return strings.Contains(s, "-") || strings.Contains(s, "/") ||
                strings.Contains(s, ":") || strings.Contains(s, " ") ||
                strings.Contains(s, "T")</span>
}

// parseWildcard parses a wildcard pattern and returns a regex BSON query
func (f *MongoFormatter) parseWildcard(valueStr string) (bson.M, error) <span class="cov4" title="30">{
        pattern := strings.ReplaceAll(valueStr, "*", ".*")

        // Add proper anchoring based on wildcard position
        if f.isContainsPattern(valueStr) </span>{<span class="cov3" title="6">
                // *J* - contains pattern
        }</span> else<span class="cov4" title="24"> if f.isEndsWithPattern(valueStr) </span><span class="cov2" title="3">{
                // *J - ends with pattern
                pattern = pattern + "$"
        }</span> else<span class="cov4" title="21"> if f.isStartsWithPattern(valueStr) </span><span class="cov4" title="19">{
                // J* - starts with pattern
                pattern = "^" + pattern
        }</span> else<span class="cov1" title="2"> {
                // J*K - starts and ends with specific patterns
                pattern = "^" + pattern + "$"
        }</span>

        <span class="cov4" title="30">return bson.M{"$regex": pattern, "$options": "i"}, nil</span>
}

// isContainsPattern checks if the pattern is a contains pattern (*J*)
func (f *MongoFormatter) isContainsPattern(valueStr string) bool <span class="cov4" title="30">{
        return strings.HasPrefix(valueStr, "*") &amp;&amp; strings.HasSuffix(valueStr, "*")
}</span>

// isEndsWithPattern checks if the pattern is an ends with pattern (*J)
func (f *MongoFormatter) isEndsWithPattern(valueStr string) bool <span class="cov4" title="24">{
        return strings.HasPrefix(valueStr, "*") &amp;&amp; !strings.HasSuffix(valueStr, "*")
}</span>

// isStartsWithPattern checks if the pattern is a starts with pattern (J*)
func (f *MongoFormatter) isStartsWithPattern(valueStr string) bool <span class="cov4" title="21">{
        return !strings.HasPrefix(valueStr, "*") &amp;&amp; strings.HasSuffix(valueStr, "*")
}</span>

// parseRegex parses a regex pattern and returns a regex BSON query
func (f *MongoFormatter) parseRegex(valueStr string) (bson.M, error) <span class="cov3" title="8">{
        // Remove the leading and trailing slashes
        pattern := valueStr[1 : len(valueStr)-1]

        // Return as MongoDB regex query (case-sensitive by default)
        return bson.M{"$regex": pattern}, nil
}</span>

// parseDateRange parses date range queries
func (f *MongoFormatter) parseDateRange(startStr, endStr string) (interface{}, error) <span class="cov4" title="15">{
        if err := f.validateDateRange(startStr, endStr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="15">if startStr == "*" </span><span class="cov1" title="2">{
                return f.parseDateRangeWithWildcardStart(endStr)
        }</span>

        <span class="cov3" title="13">return f.parseDateRangeWithStart(startStr, endStr)</span>
}

// validateDateRange validates that the date range is valid
func (f *MongoFormatter) validateDateRange(startStr, endStr string) error <span class="cov4" title="15">{
        if startStr == "*" &amp;&amp; endStr == "*" </span><span class="cov0" title="0">{
                return errors.New("invalid date range: both start and end cannot be wildcards")
        }</span>
        <span class="cov4" title="15">return nil</span>
}

// parseDateRangeWithWildcardStart parses a date range with wildcard start
func (f *MongoFormatter) parseDateRangeWithWildcardStart(endStr string) (interface{}, error) <span class="cov1" title="2">{
        endDate, err := f.parseDate(endStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="2">return bson.M{"$lte": endDate}, nil</span>
}

// parseDateRangeWithStart parses a date range with a start value
func (f *MongoFormatter) parseDateRangeWithStart(startStr, endStr string) (interface{}, error) <span class="cov3" title="13">{
        startDate, err := f.parseDate(startStr)
        if err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>

        <span class="cov3" title="11">result := bson.M{"$gte": startDate}

        if endStr != "*" </span><span class="cov3" title="9">{
                endDate, err := f.parseDate(endStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="9">result["$lte"] = endDate</span>
        }

        <span class="cov3" title="11">return result, nil</span>
}

// parseDate parses a date string in various formats
func (f *MongoFormatter) parseDate(dateStr string) (time.Time, error) <span class="cov7" title="395">{
        if date, err := time.Parse(time.RFC3339, dateStr); err == nil </span><span class="cov1" title="1">{
                return date, nil
        }</span>

        <span class="cov7" title="394">formats := []string{
                "2006-01-02",
                "2006-01-02T15:04:05Z",
                "2006-01-02T15:04:05",
                "2006-01-02 15:04:05",
                "01/02/2006",
                "2006/01/02",
        }

        for _, format := range formats </span><span class="cov9" title="2133">{
                if date, err := time.Parse(format, dateStr); err == nil </span><span class="cov5" title="49">{
                        return date, nil
                }</span>
        }

        <span class="cov7" title="345">return time.Time{}, errors.New("unable to parse date: " + dateStr)</span>
}

// parseNumberRange parses number range queries
func (f *MongoFormatter) parseNumberRange(startStr, endStr string) (interface{}, error) <span class="cov4" title="26">{
        if err := f.validateNumberRange(startStr, endStr); err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>

        <span class="cov4" title="24">if startStr == "*" </span><span class="cov2" title="4">{
                return f.parseNumberRangeWithWildcardStart(endStr)
        }</span>

        <span class="cov4" title="20">return f.parseNumberRangeWithStart(startStr, endStr)</span>
}

// validateNumberRange validates that the number range is valid
func (f *MongoFormatter) validateNumberRange(startStr, endStr string) error <span class="cov4" title="26">{
        if startStr == "*" &amp;&amp; endStr == "*" </span><span class="cov1" title="2">{
                return errors.New("invalid number range: both start and end cannot be wildcards")
        }</span>
        <span class="cov4" title="24">return nil</span>
}

// parseNumberRangeWithWildcardStart parses a number range with wildcard start
func (f *MongoFormatter) parseNumberRangeWithWildcardStart(endStr string) (interface{}, error) <span class="cov2" title="4">{
        endNum, err := strconv.ParseFloat(endStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid end number: %v", err)
        }</span>
        <span class="cov2" title="4">return bson.M{"$lte": endNum}, nil</span>
}

// parseNumberRangeWithStart parses a number range with a start value
func (f *MongoFormatter) parseNumberRangeWithStart(startStr, endStr string) (interface{}, error) <span class="cov4" title="20">{
        startNum, err := strconv.ParseFloat(startStr, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid start number: %v", err)
        }</span>

        <span class="cov4" title="20">result := bson.M{"$gte": startNum}

        if endStr != "*" </span><span class="cov4" title="16">{
                endNum, err := strconv.ParseFloat(endStr, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid end number: %v", err)
                }</span>
                <span class="cov4" title="16">result["$lte"] = endNum</span>
        }

        <span class="cov4" title="20">return result, nil</span>
}

// expressionToBSON converts a ParticipleExpression to BSON
func (f *MongoFormatter) expressionToBSON(expr *lucene.ParticipleExpression) bson.M <span class="cov7" title="304">{
        if len(expr.Or) == 0 </span><span class="cov0" title="0">{
                return bson.M{}
        }</span>

        <span class="cov7" title="304">if len(expr.Or) == 1 </span><span class="cov7" title="230">{
                return f.andExpressionToBSON(expr.Or[0])
        }</span>

        // Check if all OR conditions are text searches
        <span class="cov5" title="74">textSearches := f.extractTextSearches(expr.Or)
        if len(textSearches) &gt; 0 &amp;&amp; len(textSearches) == len(expr.Or) </span><span class="cov3" title="7">{
                // All conditions are text searches, combine them into a single $text expression
                return f.combineTextSearches(textSearches)
        }</span>

        <span class="cov5" title="67">var conditions []bson.M
        for _, andExpr := range expr.Or </span><span class="cov6" title="136">{
                conditions = append(conditions, f.andExpressionToBSON(andExpr))
        }</span>
        <span class="cov5" title="67">return bson.M{"$or": conditions}</span>
}

// andExpressionToBSON converts a ParticipleAndExpression to BSON
func (f *MongoFormatter) andExpressionToBSON(andExpr *lucene.ParticipleAndExpression) bson.M <span class="cov7" title="366">{
        if len(andExpr.And) == 0 </span><span class="cov0" title="0">{
                return bson.M{}
        }</span>

        <span class="cov7" title="366">if len(andExpr.And) == 1 </span><span class="cov7" title="272">{
                return f.notExpressionToBSON(andExpr.And[0])
        }</span>

        <span class="cov6" title="94">directFields, conditions := f.processAndExpressions(andExpr.And)
        return f.buildAndResult(directFields, conditions)</span>
}

// processAndExpressions processes all AND expressions and separates simple fields from complex conditions
func (f *MongoFormatter) processAndExpressions(expressions []*lucene.ParticipleNotExpression) (bson.M, []bson.M) <span class="cov6" title="94">{
        var conditions []bson.M
        directFields := bson.M{}
        hasComplexExpressions := false

        for _, notExpr := range expressions </span><span class="cov6" title="191">{
                childBSON := f.notExpressionToBSON(notExpr)

                if f.isSimpleFieldValue(childBSON) </span><span class="cov6" title="131">{
                        if f.canMergeField(directFields, childBSON, hasComplexExpressions) </span><span class="cov6" title="105">{
                                f.mergeField(directFields, childBSON)
                        }</span> else<span class="cov4" title="26"> {
                                conditions = append(conditions, childBSON)
                        }</span>
                } else<span class="cov5" title="60"> {
                        hasComplexExpressions = true
                        conditions = append(conditions, childBSON)
                }</span>
        }

        <span class="cov6" title="94">return directFields, conditions</span>
}

// canMergeField checks if a field can be merged into directFields
func (f *MongoFormatter) canMergeField(directFields bson.M, childBSON bson.M, hasComplexExpressions bool) bool <span class="cov6" title="131">{
        if hasComplexExpressions </span><span class="cov4" title="25">{
                return false
        }</span>

        // Check for field conflicts
        <span class="cov6" title="106">for k := range childBSON </span><span class="cov6" title="106">{
                if _, exists := directFields[k]; exists </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        <span class="cov6" title="105">return true</span>
}

// mergeField merges a simple field into directFields
func (f *MongoFormatter) mergeField(directFields bson.M, childBSON bson.M) <span class="cov6" title="105">{
        for k, v := range childBSON </span><span class="cov6" title="105">{
                directFields[k] = v
        }</span>
}

// buildAndResult builds the final result from directFields and conditions
func (f *MongoFormatter) buildAndResult(directFields bson.M, conditions []bson.M) bson.M <span class="cov6" title="94">{
        if len(directFields) &gt; 0 &amp;&amp; len(conditions) &gt; 0 </span><span class="cov1" title="2">{
                conditions = append(conditions, directFields)
                return bson.M{"$and": conditions}
        }</span> else<span class="cov6" title="92"> if len(conditions) &gt; 0 </span><span class="cov5" title="42">{
                return bson.M{"$and": conditions}
        }</span>
        <span class="cov5" title="50">return directFields</span>
}

// notExpressionToBSON converts a ParticipleNotExpression to BSON
func (f *MongoFormatter) notExpressionToBSON(notExpr *lucene.ParticipleNotExpression) bson.M <span class="cov8" title="609">{
        return f.notExpressionToBSONWithContext(notExpr, false)
}</span>

// notExpressionToBSONWithContext converts a ParticipleNotExpression to BSON with context
func (f *MongoFormatter) notExpressionToBSONWithContext(notExpr *lucene.ParticipleNotExpression, inNotContext bool) bson.M <span class="cov8" title="654">{
        if notExpr.Not != nil </span><span class="cov5" title="45">{
                // Handle NOT operation
                childBSON := f.notExpressionToBSONWithContext(notExpr.Not, true)
                return f.negateBSON(childBSON)
        }</span>

        <span class="cov8" title="609">return f.termToBSONWithContext(notExpr.Term, inNotContext)</span>
}

// termToBSONWithContext converts a ParticipleTerm to BSON with context
func (f *MongoFormatter) termToBSONWithContext(term *lucene.ParticipleTerm, inNotContext bool) bson.M <span class="cov8" title="609">{
        if term.FieldValue != nil </span><span class="cov8" title="472">{
                return f.fieldValueToBSONWithContext(term.FieldValue, inNotContext)
        }</span>

        <span class="cov6" title="137">if term.FreeText != nil </span><span class="cov5" title="38">{
                return f.freeTextToBSON(term.FreeText)
        }</span>

        <span class="cov6" title="99">if term.Group != nil </span><span class="cov6" title="99">{
                return f.expressionToBSON(term.Group.Expression)
        }</span>

        <span class="cov0" title="0">return bson.M{}</span>
}

// fieldValueToBSONWithContext converts a ParticipleFieldValue to BSON with context
func (f *MongoFormatter) fieldValueToBSONWithContext(fv *lucene.ParticipleFieldValue, inNotContext bool) bson.M <span class="cov8" title="474">{
        // Check if this field value should be split into field:value + free text
        if fieldValue, freeText := fv.SplitIntoFieldAndText(); fieldValue != nil </span><span class="cov1" title="2">{
                // Convert field value to BSON
                fieldBSON := f.fieldValueToBSONWithContext(fieldValue, inNotContext)

                // Convert free text to BSON
                freeTextBSON := f.freeTextToBSON(freeText)

                // Return as $and with field:value and $text search
                return bson.M{
                        "$and": []bson.M{
                                fieldBSON,
                                freeTextBSON,
                        },
                }
        }</span>

        // Single term or other value type - handle normally
        <span class="cov8" title="472">valueStr := f.extractValueString(fv.Value)
        value, err := f.parseValue(valueStr)
        if err != nil </span><span class="cov2" title="4">{
                value = valueStr
        }</span>
        <span class="cov8" title="472">return bson.M{fv.Field: value}</span>
}

// extractValueString extracts the string value from a ParticipleValue
func (f *MongoFormatter) extractValueString(value *lucene.ParticipleValue) string <span class="cov8" title="472">{
        valueExtractors := []func(*lucene.ParticipleValue) (string, bool){
                f.extractTextTerms,
                f.extractString,
                f.extractSingleString,
                f.extractBracketed,
                f.extractDateTime,
                f.extractTimeString,
                f.extractRegex,
        }

        for _, extractor := range valueExtractors </span><span class="cov8" title="705">{
                if str, found := extractor(value); found </span><span class="cov8" title="472">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// extractTextTerms extracts text terms from ParticipleValue
func (f *MongoFormatter) extractTextTerms(value *lucene.ParticipleValue) (string, bool) <span class="cov8" title="472">{
        if len(value.TextTerms) &gt; 0 </span><span class="cov7" title="370">{
                return strings.Join(value.TextTerms, " "), true
        }</span>
        <span class="cov6" title="102">return "", false</span>
}

// extractString extracts string from ParticipleValue
func (f *MongoFormatter) extractString(value *lucene.ParticipleValue) (string, bool) <span class="cov6" title="102">{
        if value.String != nil </span><span class="cov5" title="50">{
                return *value.String, true
        }</span>
        <span class="cov5" title="52">return "", false</span>
}

// extractSingleString extracts single string from ParticipleValue
func (f *MongoFormatter) extractSingleString(value *lucene.ParticipleValue) (string, bool) <span class="cov5" title="52">{
        if value.SingleString != nil </span><span class="cov0" title="0">{
                return *value.SingleString, true
        }</span>
        <span class="cov5" title="52">return "", false</span>
}

// extractBracketed extracts bracketed value from ParticipleValue
func (f *MongoFormatter) extractBracketed(value *lucene.ParticipleValue) (string, bool) <span class="cov5" title="52">{
        if value.Bracketed != nil </span><span class="cov5" title="41">{
                return *value.Bracketed, true
        }</span>
        <span class="cov3" title="11">return "", false</span>
}

// extractDateTime extracts datetime from ParticipleValue
func (f *MongoFormatter) extractDateTime(value *lucene.ParticipleValue) (string, bool) <span class="cov3" title="11">{
        if value.DateTime != nil </span><span class="cov2" title="3">{
                return *value.DateTime, true
        }</span>
        <span class="cov3" title="8">return "", false</span>
}

// extractTimeString extracts time string from ParticipleValue
func (f *MongoFormatter) extractTimeString(value *lucene.ParticipleValue) (string, bool) <span class="cov3" title="8">{
        if value.TimeString != nil </span><span class="cov0" title="0">{
                return *value.TimeString, true
        }</span>
        <span class="cov3" title="8">return "", false</span>
}

// extractRegex extracts regex from ParticipleValue
func (f *MongoFormatter) extractRegex(value *lucene.ParticipleValue) (string, bool) <span class="cov3" title="8">{
        if value.Regex != nil </span><span class="cov3" title="8">{
                return *value.Regex, true
        }</span>
        <span class="cov0" title="0">return "", false</span>
}

// freeTextToBSON converts a ParticipleFreeText to BSON using MongoDB's $text search
func (f *MongoFormatter) freeTextToBSON(ft *lucene.ParticipleFreeText) bson.M <span class="cov5" title="40">{
        var valueStr string

        if ft.QuotedValue != nil </span><span class="cov4" title="23">{
                // Handle quoted values
                if ft.QuotedValue.String != nil </span><span class="cov4" title="20">{
                        valueStr = *ft.QuotedValue.String
                }</span> else<span class="cov2" title="3"> if ft.QuotedValue.SingleString != nil </span><span class="cov2" title="3">{
                        valueStr = *ft.QuotedValue.SingleString
                }</span>
                // For quoted values, keep them quoted for exact phrase matching
                <span class="cov4" title="23">return bson.M{"$text": bson.M{"$search": fmt.Sprintf("\"%s\"", valueStr)}}</span>
        } else<span class="cov4" title="17"> if ft.UnquotedValue != nil </span><span class="cov4" title="17">{
                // Handle unquoted values
                valueStr = strings.Join(ft.UnquotedValue.TextTerms, " ")
                // For unquoted values, use them as-is for term-based search
                return bson.M{"$text": bson.M{"$search": valueStr}}
        }</span>

        // Fallback (should not happen with proper grammar)
        <span class="cov0" title="0">return bson.M{"$text": bson.M{"$search": ""}}</span>
}

// extractTextSearches extracts text search strings from OR conditions
func (f *MongoFormatter) extractTextSearches(andExpressions []*lucene.ParticipleAndExpression) []string <span class="cov5" title="74">{
        var textSearches []string

        for _, andExpr := range andExpressions </span><span class="cov6" title="150">{
                if len(andExpr.And) == 1 </span><span class="cov6" title="146">{
                        // Check if this is a simple text search
                        bsonResult := f.notExpressionToBSON(andExpr.And[0])
                        if textSearch, isTextSearch := f.extractTextSearchString(bsonResult); isTextSearch </span><span class="cov4" title="14">{
                                textSearches = append(textSearches, textSearch)
                        }</span>
                }
        }

        <span class="cov5" title="74">return textSearches</span>
}

// extractTextSearchString extracts the search string from a $text BSON expression
func (f *MongoFormatter) extractTextSearchString(bsonResult bson.M) (string, bool) <span class="cov6" title="146">{
        textOp, hasText := bsonResult["$text"]
        if !hasText </span><span class="cov6" title="132">{
                return "", false
        }</span>

        <span class="cov4" title="14">textMap, ok := textOp.(bson.M)
        if !ok </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov4" title="14">search, hasSearch := textMap["$search"]
        if !hasSearch </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov4" title="14">searchStr, ok := search.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov4" title="14">return f.processSearchString(searchStr), true</span>
}

// processSearchString processes the search string by removing quotes if present
func (f *MongoFormatter) processSearchString(searchStr string) string <span class="cov4" title="14">{
        // For quoted searches, remove the quotes for combination
        if f.isQuotedString(searchStr) </span><span class="cov3" title="8">{
                return searchStr[1 : len(searchStr)-1]
        }</span>
        // For unquoted searches, return as-is
        <span class="cov3" title="6">return searchStr</span>
}

// isQuotedString checks if a string is wrapped in quotes
func (f *MongoFormatter) isQuotedString(s string) bool <span class="cov4" title="14">{
        return len(s) &gt;= 2 &amp;&amp; s[0] == '"' &amp;&amp; s[len(s)-1] == '"'
}</span>

// combineTextSearches combines multiple text search strings into a single $text expression
func (f *MongoFormatter) combineTextSearches(textSearches []string) bson.M <span class="cov3" title="7">{
        // For MongoDB text search, multiple unquoted terms are OR'd by default
        // We need to extract individual words from each phrase for OR behavior
        var allTerms []string
        for _, search := range textSearches </span><span class="cov4" title="14">{
                // Split each search phrase into individual words
                words := strings.Fields(search)
                allTerms = append(allTerms, words...)
        }</span>

        // Join all terms with spaces for OR behavior
        <span class="cov3" title="7">combinedSearch := strings.Join(allTerms, " ")

        return bson.M{"$text": bson.M{"$search": combinedSearch}}</span>
}

// negateBSON negates a BSON condition using De Morgan's law
func (f *MongoFormatter) negateBSON(condition bson.M) bson.M <span class="cov5" title="45">{
        if orClause, hasOr := condition["$or"]; hasOr </span><span class="cov3" title="9">{
                return bson.M{"$and": f.negateConditions(orClause.([]bson.M))}
        }</span>

        <span class="cov5" title="36">if andClause, hasAnd := condition["$and"]; hasAnd </span><span class="cov1" title="2">{
                return bson.M{"$or": f.negateConditions(andClause.([]bson.M))}
        }</span>

        <span class="cov5" title="34">result := bson.M{}
        for k, v := range condition </span><span class="cov5" title="37">{
                result[k] = bson.M{"$ne": v}
        }</span>
        <span class="cov5" title="34">return result</span>
}

// negateConditions negates a list of conditions by adding $ne operators
func (f *MongoFormatter) negateConditions(conditions []bson.M) []bson.M <span class="cov3" title="11">{
        var result []bson.M
        for _, condition := range conditions </span><span class="cov4" title="23">{
                negated := bson.M{}
                for k, v := range condition </span><span class="cov4" title="23">{
                        negated[k] = bson.M{"$ne": v}
                }</span>
                <span class="cov4" title="23">result = append(result, negated)</span>
        }
        <span class="cov3" title="11">return result</span>
}

// isSimpleFieldValue checks if a BSON condition is a simple field:value pair
func (f *MongoFormatter) isSimpleFieldValue(condition bson.M) bool <span class="cov6" title="191">{
        if len(condition) != 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if the condition itself has complex operators
        <span class="cov6" title="191">if f.hasComplexOperators(condition) </span><span class="cov5" title="60">{
                return false
        }</span>

        // Check if any field value contains complex operators
        <span class="cov6" title="131">return !f.hasComplexFieldValues(condition)</span>
}

// hasComplexOperators checks if a BSON condition contains complex operators
func (f *MongoFormatter) hasComplexOperators(condition bson.M) bool <span class="cov6" title="191">{
        complexOperators := []string{"$or", "$and", "$text"}
        for _, op := range complexOperators </span><span class="cov8" title="503">{
                if _, hasOp := condition[op]; hasOp </span><span class="cov5" title="60">{
                        return true
                }</span>
        }
        <span class="cov6" title="131">return false</span>
}

// hasComplexFieldValues checks if any field value contains complex operators
func (f *MongoFormatter) hasComplexFieldValues(condition bson.M) bool <span class="cov6" title="131">{
        complexOperators := []string{"$or", "$and", "$text"}
        for _, v := range condition </span><span class="cov6" title="131">{
                if vMap, ok := v.(bson.M); ok </span><span class="cov5" title="46">{
                        for key := range vMap </span><span class="cov5" title="60">{
                                for _, op := range complexOperators </span><span class="cov6" title="180">{
                                        if key == op </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov6" title="131">return false</span>
}

// init registers the MongoDB formatter with the global registry.
func init() <span class="cov1" title="1">{
        registry.RegisterFormatter(config.FormatterMongo, func() formatter.Formatter[bson.M] </span><span class="cov4" title="15">{
                return New()
        }</span>)
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package lucene provides Lucene-style syntax parsing functionality.
package lucene

import (
        "github.com/alecthomas/participle/v2"
        "github.com/alecthomas/participle/v2/lexer"
        "github.com/kyle-williams-1/bsonic/config"
        "github.com/kyle-williams-1/bsonic/language"
        "github.com/kyle-williams-1/bsonic/registry"
)

// Participle Grammar structures for Lucene-style queries

// ParticipleQuery is the root of the Participle AST
type ParticipleQuery struct {
        Expression *ParticipleExpression `@@`
}

// ParticipleExpression handles OR operations (lowest precedence)
type ParticipleExpression struct {
        Or []*ParticipleAndExpression `@@ ( "OR" @@ )*`
}

// ParticipleAndExpression handles AND operations (higher precedence than OR)
type ParticipleAndExpression struct {
        And []*ParticipleNotExpression `@@ ( "AND" @@ )*`
}

// ParticipleNotExpression handles NOT operations (highest precedence)
type ParticipleNotExpression struct {
        Not  *ParticipleNotExpression `"NOT" @@`
        Term *ParticipleTerm          `| @@`
}

// ParticipleTerm represents individual query terms
type ParticipleTerm struct {
        FieldValue *ParticipleFieldValue `@@`
        FreeText   *ParticipleFreeText   `| @@`
        Group      *ParticipleGroup      `| @@`
}

// ParticipleFieldValue represents field:value pairs
type ParticipleFieldValue struct {
        Field string           `@TextTerm ":"`
        Value *ParticipleValue `@@`
}

// SplitIntoFieldAndText splits a field value into field:value and free text if the value contains multiple text terms
// Returns the field value (with single term) and optional free text, or nil if no splitting is needed
func (fv *ParticipleFieldValue) SplitIntoFieldAndText() (*ParticipleFieldValue, *ParticipleFreeText) <span class="cov10" title="474">{
        // Only split if we have multiple text terms
        if fv.Value == nil || len(fv.Value.TextTerms) &lt;= 1 </span><span class="cov9" title="472">{
                return nil, nil
        }</span>

        // Create new field value with just the first term
        <span class="cov2" title="2">fieldValue := &amp;ParticipleFieldValue{
                Field: fv.Field,
                Value: &amp;ParticipleValue{
                        TextTerms: []string{fv.Value.TextTerms[0]},
                },
        }

        // Create free text with remaining terms
        freeText := &amp;ParticipleFreeText{
                UnquotedValue: &amp;ParticipleUnquotedValue{
                        TextTerms: fv.Value.TextTerms[1:],
                },
        }

        return fieldValue, freeText</span>
}

// ParticipleFreeText represents free text search queries (quoted or unquoted text without field names)
type ParticipleFreeText struct {
        QuotedValue   *ParticipleQuotedValue   `@@`
        UnquotedValue *ParticipleUnquotedValue `| @@`
}

// ParticipleQuotedValue represents quoted values for free text search
type ParticipleQuotedValue struct {
        String       *string `@String`
        SingleString *string `| @SingleString`
}

// ParticipleUnquotedValue represents unquoted text for free text search
type ParticipleUnquotedValue struct {
        TextTerms []string `@TextTerm+`
}

// ParticipleValue represents a value that can be a text term or quoted string
type ParticipleValue struct {
        TextTerms    []string `@TextTerm+`
        String       *string  `| @String`
        SingleString *string  `| @SingleString`
        Bracketed    *string  `| @Bracketed`
        DateTime     *string  `| @DateTime`
        TimeString   *string  `| @TimeString`
        Regex        *string  `| @Regex`
}

// ParticipleGroup represents parenthesized expressions
type ParticipleGroup struct {
        Expression *ParticipleExpression `"(" @@ ")"`
}

// Lexer definition for Lucene-style queries
var luceneLexer = lexer.MustSimple([]lexer.SimpleRule{
        // Whitespace
        {Name: "Whitespace", Pattern: `\s+`},
        // Logical operators
        {Name: "AND", Pattern: `AND`},
        {Name: "OR", Pattern: `OR`},
        {Name: "NOT", Pattern: `NOT`},
        // Parentheses
        {Name: "LParen", Pattern: `\(`},
        {Name: "RParen", Pattern: `\)`},
        // Quoted strings - must come before TextTerm
        {Name: "String", Pattern: `"([^"\\]|\\.)*"`},
        // Single quoted strings - must come before TextTerm
        {Name: "SingleString", Pattern: `'([^'\\]|\\.)*'`},
        // Regex patterns - must come before Bracketed
        {Name: "Regex", Pattern: `/([^/\\]|\\.)*/`},
        // Date ranges and other bracketed expressions
        {Name: "Bracketed", Pattern: `\[[^\]]+\]`},
        // Datetime strings with colons (ISO format, etc.)
        {Name: "DateTime", Pattern: `\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})?`},
        // Time strings with colons
        {Name: "TimeString", Pattern: `\d{2}:\d{2}:\d{2}(\.\d+)?`},
        // Colon separator - must come after datetime patterns
        {Name: "Colon", Pattern: `:`},
        // Text terms (can be field names or values) - pattern includes wildcards
        {Name: "TextTerm", Pattern: `[^:\s\[\]()]+`},
})

// Parser instance using Participle
var participleParser = participle.MustBuild[ParticipleQuery](
        participle.Lexer(luceneLexer),
        participle.Unquote("String", "SingleString"),
        participle.UseLookahead(2),
        participle.Elide("Whitespace"),
)

// Parser represents a Lucene-style query parser.
type Parser struct{}

// New creates a new Lucene parser instance.
func New() *Parser <span class="cov4" title="15">{
        return &amp;Parser{}
}</span>

// Parse parses a Lucene-style query string into an AST.
func (p *Parser) Parse(query string) (interface{}, error) <span class="cov8" title="221">{
        return participleParser.ParseString("", query)
}</span>

// init registers the Lucene language with the global registry.
func init() <span class="cov1" title="1">{
        registry.RegisterLanguage(config.LanguageLucene, func() language.Parser </span><span class="cov4" title="15">{
                return New()
        }</span>)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package registry provides dynamic discovery and registration of languages and formatters.
package registry

import (
        "fmt"

        "github.com/kyle-williams-1/bsonic/config"
        "github.com/kyle-williams-1/bsonic/formatter"
        "github.com/kyle-williams-1/bsonic/language"
        "go.mongodb.org/mongo-driver/bson"
)

// LanguageFactory creates a new language parser instance.
type LanguageFactory func() language.Parser

// FormatterFactory creates a new formatter instance.
type FormatterFactory func() formatter.Formatter[bson.M]

// LanguageRegistry manages available language parsers.
type LanguageRegistry struct {
        languages map[config.LanguageType]LanguageFactory
}

// FormatterRegistry manages available formatters.
type FormatterRegistry struct {
        formatters map[config.FormatterType]FormatterFactory
}

// Registry combines language and formatter registries.
type Registry struct {
        Languages  *LanguageRegistry
        Formatters *FormatterRegistry
}

// New creates a new registry with default languages and formatters.
func New() *Registry <span class="cov1" title="1">{
        return &amp;Registry{
                Languages:  NewLanguageRegistry(),
                Formatters: NewFormatterRegistry(),
        }
}</span>

// NewLanguageRegistry creates a new language registry with default languages.
func NewLanguageRegistry() *LanguageRegistry <span class="cov1" title="1">{
        registry := &amp;LanguageRegistry{
                languages: make(map[config.LanguageType]LanguageFactory),
        }
        
        // Register default languages
        // Note: This will be populated by the init() functions in language packages
        return registry
}</span>

// NewFormatterRegistry creates a new formatter registry with default formatters.
func NewFormatterRegistry() *FormatterRegistry <span class="cov1" title="1">{
        registry := &amp;FormatterRegistry{
                formatters: make(map[config.FormatterType]FormatterFactory),
        }
        
        // Register default formatters
        // Note: This will be populated by the init() functions in formatter packages
        return registry
}</span>

// RegisterLanguage registers a language factory.
func (lr *LanguageRegistry) RegisterLanguage(langType config.LanguageType, factory LanguageFactory) <span class="cov1" title="1">{
        lr.languages[langType] = factory
}</span>

// RegisterFormatter registers a formatter factory.
func (fr *FormatterRegistry) RegisterFormatter(formatterType config.FormatterType, factory FormatterFactory) <span class="cov1" title="1">{
        fr.formatters[formatterType] = factory
}</span>

// GetLanguage creates a language parser instance.
func (lr *LanguageRegistry) GetLanguage(langType config.LanguageType) (language.Parser, error) <span class="cov10" title="17">{
        factory, exists := lr.languages[langType]
        if !exists </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("unsupported language type: %s", langType)
        }</span>
        <span class="cov9" title="15">return factory(), nil</span>
}

// GetFormatter creates a formatter instance.
func (fr *FormatterRegistry) GetFormatter(formatterType config.FormatterType) (formatter.Formatter[bson.M], error) <span class="cov10" title="17">{
        factory, exists := fr.formatters[formatterType]
        if !exists </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("unsupported formatter type: %s", formatterType)
        }</span>
        <span class="cov9" title="15">return factory(), nil</span>
}

// ListLanguages returns all registered language types.
func (lr *LanguageRegistry) ListLanguages() []config.LanguageType <span class="cov0" title="0">{
        var languages []config.LanguageType
        for langType := range lr.languages </span><span class="cov0" title="0">{
                languages = append(languages, langType)
        }</span>
        <span class="cov0" title="0">return languages</span>
}

// ListFormatters returns all registered formatter types.
func (fr *FormatterRegistry) ListFormatters() []config.FormatterType <span class="cov0" title="0">{
        var formatters []config.FormatterType
        for formatterType := range fr.formatters </span><span class="cov0" title="0">{
                formatters = append(formatters, formatterType)
        }</span>
        <span class="cov0" title="0">return formatters</span>
}

// ValidateConfig validates that a language-formatter combination is supported.
func (r *Registry) ValidateConfig(cfg *config.Config) error <span class="cov4" title="3">{
        _, err := r.Languages.GetLanguage(cfg.Language)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid language: %w", err)
        }</span>
        
        <span class="cov3" title="2">_, err = r.Formatters.GetFormatter(cfg.Formatter)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid formatter: %w", err)
        }</span>
        
        <span class="cov1" title="1">return nil</span>
}

// Global registry instance
var DefaultRegistry = New()

// RegisterLanguage registers a language with the global registry.
func RegisterLanguage(langType config.LanguageType, factory LanguageFactory) <span class="cov1" title="1">{
        DefaultRegistry.Languages.RegisterLanguage(langType, factory)
}</span>

// RegisterFormatter registers a formatter with the global registry.
func RegisterFormatter(formatterType config.FormatterType, factory FormatterFactory) <span class="cov1" title="1">{
        DefaultRegistry.Formatters.RegisterFormatter(formatterType, factory)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package helpers provides shared test utilities for BSON comparison and testing.
package helpers

import (
        "time"

        "go.mongodb.org/mongo-driver/bson"
)

// CompareBSONValues compares BSON values for testing
func CompareBSONValues(actual, expected interface{}) bool <span class="cov10" title="521">{
        // Handle time.Time comparison
        if actualTime, ok := actual.(time.Time); ok </span><span class="cov5" title="26">{
                return compareTimeValues(actualTime, expected)
        }</span>

        // Handle bson.M comparison
        <span class="cov9" title="495">if actualMap, ok := actual.(bson.M); ok </span><span class="cov9" title="284">{
                return compareBSONMaps(actualMap, expected)
        }</span>

        // Handle []bson.M comparison
        <span class="cov8" title="211">if actualArray, ok := actual.([]bson.M); ok </span><span class="cov6" title="42">{
                return compareBSONArrays(actualArray, expected)
        }</span>

        // Default comparison
        <span class="cov8" title="169">return actual == expected</span>
}

// compareTimeValues compares time.Time values
func compareTimeValues(actualTime time.Time, expected interface{}) bool <span class="cov5" title="26">{
        expectedTime, ok := expected.(time.Time)
        return ok &amp;&amp; actualTime.Equal(expectedTime)
}</span>

// compareBSONMaps compares bson.M values
func compareBSONMaps(actualMap bson.M, expected interface{}) bool <span class="cov9" title="284">{
        expectedMap, ok := expected.(bson.M)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov9" title="284">if len(actualMap) != len(expectedMap) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov9" title="284">for key, expectedValue := range expectedMap </span><span class="cov9" title="329">{
                actualValue, exists := actualMap[key]
                if !exists || !CompareBSONValues(actualValue, expectedValue) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov9" title="284">return true</span>
}

// compareBSONArrays compares []bson.M values
func compareBSONArrays(actualArray []bson.M, expected interface{}) bool <span class="cov6" title="42">{
        expectedArray, ok := expected.([]bson.M)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov6" title="42">if len(actualArray) != len(expectedArray) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov6" title="42">for i, expectedValue := range expectedArray </span><span class="cov7" title="85">{
                if !CompareBSONValues(actualArray[i], expectedValue) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov6" title="42">return true</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
